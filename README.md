# Analysis

I'm gonna take you step by step through my code here, but first an overall picture: I decided to implement this as an API endpoint served by a Ruby on Rails backend. Whatever purpose the frontend will be using the information for, it can be retrieved with a simple API call and the logic behind it is all abstracted away. The frontend could be as simple as a button that one clicks to retrieve the information before displaying it. I chose Rails as my backend mostly because it's the one I have the most familiarity with, but also because with Ruby's massive gem library I figured there would almost certainly be the right tools to help me with my goal (I was right). I included the built-in Net::HTTP and JSON Ruby modules to deal with API calls and JSON parsing, and I also included the Haversine gem, which calculates the distance between two GPS coordinate points using the Haversine formula. I didn't want to rely on an external API for the distance calculation because I assumed it would eat up extra time, both the actual time of the call to the API, and the probable extra iterations through the drone and package lists it would to take to build the API request and extract the response data. The Haversine gem simply takes your two coordinate points and does the calculations itself.

All right, now for how the code works. The API endpoint is routed at ```/assignments```, so a GET request to this route will hit the assignments controller and enter the ```index``` method. Once inside, the first thing we do is retrieve our drone info and give each drone some extra information that we're going to need to make our assignments. When we enter the ```populate_drones``` method, the API call is made using Net:HTTP and the response is parsed using the JSON module's ```parse``` method before being assigned to a variable. We have each drone's location and package information, but we don't yet know how far it will have to travel to make its delivery and get back to the hub or how long it will take to do so, so we need to iterate through the drones and figure this out for each one.

Inside the each loop, we establish two variables for each iteration, ```distance_to_return```, which is initialized to 0, and ```drone_location```, which is just an array of the location's latitude and longitude values, extracted for the sake of simplicity in later use. Then, we calculate the return distance. Here we have an if/else statement: if the drone's package attribute is empty, we only need to see calculate how far the drone is from the hub. A separate method, ```distance_from_hub```, is invoked, which takes in one pair of coordinates (in this case the drone's location) and feeds it into the Haversine formula along with the hub's coordinates and returns the distance in kilometers, which is added to the ```distance_to_return```. If the drone does have a package, then we need to add both the distance between the drone's initial location and destination and the distance between the package's destination and the hub to the ```distance_to_return``` variable. Finally, once we have that we can compute the time it will take to return to the hub. If the drone can travel 50 km/h (which I saw you just changed from 20...you sly dogs!), then to determine how many seconds it will take to return we multiply ```distance_to_return``` by 3600 (the number of seconds in an hour) and divide by 50. We save this number of seconds as an attribute of the drone because we'll need it later for making assignments, but we won't need our distance calculation so, to save on space, we let it expire once the iteration of the loop has concluded. Once we've processed all the drones we return our finished array back to the ```index``` method and save it in a ```drones``` variable.

Now it's time to head to the ```populate_packages``` method, which works similarly. We make the API call and assign the parsed response to a variable, then iterate through it. For each package, we need to determine a couple of pieces of information. We need to know the number of seconds until the deadline, which we can determine by subtracting ```Time.now``` from the ```deadline``` attribute. This will come in handy later, so it's saved as an attribute. Then we determine the distance from the hub to the package's destination, again using our ```distance_from_hub``` method, and the number of seconds it will take to get there by the same way we did it with the drones. The time it will take is again saved as an attribute of the package, and once we've done this for every package, we again return the array back to the ```index``` method and save it to a new variable.

All right, so we're back in the ```index``` method, we've retrieved the packages and drones, and we've made all the calculations we're going to need to make our assignments, so let's get to it. By my logic, if we're trying to get as many packages delivered by deadline as possible, we need to know which packages have the shortest amount of time to make it to their deadline, so we can match them with the drones that will take the least amount of time to return to the hub. To do this, we sort the drones by ```time_to_return``` and the packages like so: ```packages.sort_by! { |package| (package['secs_until_deadline'] - package['time_to_destination']) }```. This arranges the packages by the amount of time they can wait for a drone to return and still make deadline, from least to most. Now that we're properly sorted, making our assignments is a breeze.

So our drones and packages are passed into the ```assign_jobs``` method, where we create a new hash, ```assigned_jobs``` to hold our assignments and unassigned package IDs before going into an ```until``` loop that runs until the packages array is empty. Inside the loop, we compare the first drone and package in their respective arrays. The first package is the one that has the least amount of time available to wait for a drone and the first drone is the one that will take the least amount of time to return, so if the drone's return time added to the package's delivery time is greater than the ```secs_until_deadline``` of the package, we know that package is a lost cause and we push its ID into the ```unassignedPackageIds``` array of our new hash. If it isn't, then we bind the package and drone IDs into a hash and push that into the ```assignments``` array of ```assigned_jobs``` and ```shift``` the first element off the drones array. Then, regardless of whether the package is assigned or not, we ```shift``` that off its array too. Eventually, each package will be checked for a viable drone and shifted out of the array, leaving the packages array empty, which allows us to break out of our loop and return ```assigned_jobs``` back to the index method to be stored into a variable and finally rendered as JSON.

Whew! That was a mouthful. But to address your final question: would this solution still work if it was thousands of packages being assigned to thousands of drones per second? Well, I can say this: according to the terms of the challenge, I think this is as efficient as it can possibly be. The packages and drones both have to be iterated through completely to dig out their travel times, and they both need to be sorted to match up as well as possible. But no, I think as it stands, it couldn't scale that high because the sorts are simply too expensive. I took the liberty of timing them a few times while I was testing the code and for an average of maybe 30 packages or drones it took anywhere from .3-.8 seconds to sort, and given that Ruby's sort method uses quicksort, which has a time complexity of O(n log(n)), an extra few thousand tasks a second is going to get out of hand quickly. Not to mention that if in this real-world scenario we're relying on an external API for our data, that alone is going to take it a few seconds just to retrieve.

One way it could be made more efficient, however, is to have both the calculations and the sorts already handled by a database before the drones and packages get matched up by the controller. I'm assuming the API is meant to simulate a database for this challenge, but if, for instance, the flight times were calculated upon entry to the database and automatically given columns, and the data was already sorted by the database using ```ORDER BY``` (which I'm told is much faster than any sort function in any scripting language) before the retrieval, all the controller would have to do is run through the packages. Alas, as is I don't think this solution will scale. Unless you just add a bunch of servers, I guess.

Thanks for this challenge, it was fun.
